const crypto  = require('crypto');
const {uploadAssetFile} = require('./upload-asset');
//..............................................................................
const {logger, path, util} = cxq;
//..............................................................................

//..............................................................................
const
{
    doCallback,
    processFunctionListSerial,
    fileToSha256MultiHash,
    jsonToSha256Hex,
    getExistingKeyPair,
    encryptFile,
    decryptFile,
} = util;
//..............................................................................

//..............................................................................
const log = logger('add-hashed-asset');
log.setLevel('debug');
//..............................................................................

//..............................................................................
// Given a file path, and a public-key ID:
// Get the public - key from the public-key ID
// - Make a secret-key from hash of the file and public-key ID
// - Encrypt the secret-key with the pubic-key
// - Encrypt the file with the encrypted secret-key.
// - Add the secure-asset file (encrypted source-file) to the cloud.
//..............................................................................
// To use the asset, you need:
// - Secure-asset ID
// - Encrypted secret-key
// - Private-key
// Do the following
// - Download the asset file
// - Decrypt the encrypted secret-key using the private-key
// - Use the decrypted secret-key to decrypt the secure-asset
//..............................................................................
function addSecureAsset({plainAssetPath, publicKeyId, filename}, mainCallback)
{
    const fileExtension     = path.extname(plainAssetPath);
    const secureAssetPath   = plainAssetPath + '.enc';
    const finalFilePath     = secureAssetPath + fileExtension;

    log.info('addSecureAsset:',{plainAssetPath, publicKeyId});

    let   dataEncryptionKey   = null;
    let   encryptedKey        = null;
    let   decryptedKey        = null;
    let   publicKey           = null;
    let   privateKey          = null;

    let   plainAssetHash      = null;
    let   secureAssetHash     = null;
    let   finalHash           = null;
    let   remoteAssetInfo     = null;
    let   downloadedAssetInfo = null;
    //...........................................................................
    function dumpInfo(callback)
    {
        log.debug();
        log.debug('---------------------------------------------------------');
        log.debug('publicKey' );
        log.debug('---------------------------------------------------------');
        log.debug( publicKey );
        log.debug();
        log.debug('---------------------------------------------------------');
        log.debug('plainAssetPath   :', plainAssetPath   );
        log.debug('secureAssetPath  :', secureAssetPath  );
        log.debug('finalFilePath    :', finalFilePath    );
        log.debug('---------------------------------------------------------');
        log.debug();
        log.debug('---------------------------------------------------------');
        log.debug('dataEncryptionKey:', dataEncryptionKey);
        log.debug('encryptedKey     :', encryptedKey     );
        log.debug('decryptedKey     :', decryptedKey     );
        log.debug('publicKeyId      :', publicKeyId      );
        log.debug('---------------------------------------------------------');
        log.debug();
        if (callback) doCallback(callback);
    }
    // dumpInfo();
    // abort();
    //..........................................................................
    function getPublicKey(callback)
    {
        getExistingKeyPair(publicKeyId, function(err, keyInfo)
        {
            if (err)
            {
                log.warn('getPublicKey:Failed:',err);
                callback(err);
            }
            else
            {
                publicKey  = keyInfo.publicKey;
                privateKey = keyInfo.privateKey;
                log.trace();
                log.trace('-------------------------------------------------');
                log.trace('getKeyPair:hashCheck:',keyInfo.hashCheck);
                log.trace('-------------------------------------------------');
                log.trace(keyInfo.publicKey);
                log.trace(keyInfo.privateKey);
                log.trace('-------------------------------------------------');
                callback(null);
            }
        });
    }
    //..........................................................................
    function encryptKey(callback)
    {
        encryptedKey = crypto.publicEncrypt (publicKey , dataEncryptionKey);
        log.debug('encryptKey:done:',encryptedKey);
        doCallback(callback);
    }
    //..........................................................................
    function decryptKey(callback)
    {
        decryptedKey = crypto.privateDecrypt(privateKey, encryptedKey);
        log.debug('decryptKey:done:',decryptedKey);
        doCallback(callback);
    }
    //...........................................................................
    function getSourceHash(callback)
    {
        fileToSha256MultiHash(plainAssetPath, function(err, hash, hex)
        {
            if (err)
            {
                log.warn('getSourceHash:Callback:Error:', err);
                callback(err)
            }
            else
            {
                // Make a key that is based on the hash of the file and the public key ID we are using to secure it.
                // This needs to be deterministic or will result in different asset every time we add the same content.
                // This means that we get a unique encryption key for each different file and public-key combination.
                // Cannot determine the value of this key unless have the original file to do the hash on.
                // This key is only used to secure this file so this should be fine - if can figure out the key then must have the file already.

                const hashForKey = jsonToSha256Hex({hash, publicKeyId});
                plainAssetHash = hash;
                const hashBuf = Buffer.from(hashForKey, 'hex');

                log.debug('HashHex:',hashForKey, 'Buffer:',hashBuf.length, hashBuf);

                dataEncryptionKey = hashBuf;
                // encryptedKey    = crypto.publicEncrypt (publicKey , dataEncryptionKey);
                // decryptedKey    = crypto.privateDecrypt(privateKey, encryptedKey     );

                callback(null);
            }
        });
    }
    //..........................................................................
    function getTargetHash(callback)
    {
        fileToSha256MultiHash(secureAssetPath, function(err, hash)
        {
            if (err)
            {
                log.warn('getTargetHash:Callback:Error:', err);
                callback(err)
            }
            else
            {
                secureAssetHash = hash;
                log.debug('secureAssetHash:',secureAssetHash);
                callback(null);
            }
        });
    }
    //..........................................................................
    function getFinalHash(callback)
    {
        fileToSha256MultiHash(finalFilePath, function(err, hash, hex)
        {
            if (err)
            {
                log.warn('getFinalHash:Callback:Error:', err);
                callback(err)
            }
            else
            {
                finalHash = hash;
                log.debug('getFinalHash:Callback:source:',plainAssetHash);
                log.debug('getFinalHash:Callback:target:',secureAssetHash);
                log.debug('getFinalHash:Callback:final :',finalHash );
                callback(null);
            }
        });
    }
    //..........................................................................
    function encryptPlainAsset(callback)
    {
        encryptFile(plainAssetPath, secureAssetPath, 'aes-256-cbc', dataEncryptionKey, function(err)
        {
            if (err)
            {
                log.warn('ERROR:encryptPlainAsset:', err);
                callback(err)
            }
            else
            {
                log.debug('encryptPlainAsset:done:',{plainAssetPath, secureAssetPath});
                callback(null);
            }
        });
    }
    //..........................................................................
    function decryptSecureAsset(callback)
    {
        // We decrypt with the key that was encrypted from private, decrypted with public
        decryptFile(secureAssetPath, finalFilePath, 'aes-256-cbc', decryptedKey, function(err)
        {
            if (err)
            {
                log.warn('decryptSecureAsset:Callback:Error:', err);
                callback(err)
            }
            else
            {
                callback(null);
                log.debug('decryptSecureAsset:done:',{secureAssetPath, finalFilePath});
            }
        });
    }
    //..........................................................................
    function upload(callback)
    {
        uploadAssetFile({localPath:secureAssetPath, filename}, function(err, info)
        {
            if (err)
            {
                log.warn('ERROR:After-upload:', secureAssetPath);
                callback(err);
            }
            else
            {
                remoteAssetInfo     = info.remoteAssetInfo;
                downloadedAssetInfo = info.downloadedAssetInfo;
                log.debug('After-upload:', {remoteAssetInfo, downloadedAssetInfo});
                callback(null);
            }
        });
    }
    //..........................................................................
    function getResult()
    {
        return {
            publicKeyId,
            dataEncryptionKey,
            encryptedKey,
            decryptedKey,
            plainAssetHash,
            secureAssetHash,
            finalHash,
            remoteAssetInfo,
            downloadedAssetInfo,
        };
    }
    ////////////////////////////////////////////////////////////////////////////
    const execution =
    [
        getSourceHash,
        getPublicKey,
        encryptKey,
        decryptKey,
        encryptPlainAsset,
        getTargetHash,
        decryptSecureAsset,
        getFinalHash,
        upload
    ];
    processFunctionListSerial(execution, function(err)
    {
        log.debug('All-Done:',err);
        const result = getResult();
        log.debug('RESULT:',result);
        if (err)
            mainCallback(err);
        else
            mainCallback(null, result);
    });
}
//..............................................................................

module.exports = {addSecureAsset};