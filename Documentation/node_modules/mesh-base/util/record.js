// TODO NM: This is very out of date now
//..............................................................................
const {makeBasicCache, util} = cxq;
//..............................................................................

//..............................................................................
const
{
    oneSecond,
    addProperties,
    isDefined,
    processList,
    isObject,
    isString,
    meshHashHex,
} = util;
//..............................................................................

//..............................................................................
var recordValidatorCache;
//..............................................................................

//..............................................................................
function fieldIsPrimitiveType(field)
{
    return (isDefined(field.primitive_type));
}
//..............................................................................

//..............................................................................
function fieldIsUnitType(field)
{
    return (isDefined(field.unit_type));
}
//..............................................................................

//..............................................................................
function fieldIsPicklist(field)
{
    return (isDefined(field.picklist_type));
}
//..............................................................................

//..............................................................................
function fieldIsRelationship(field)
{
    return (isDefined(field.relationship));
}
//..............................................................................

//..............................................................................
function fieldIsRelatedList(field)
{
    return (isDefined(field.related_list));
}
//..............................................................................

//..............................................................................
function fieldIsChildModel(field)
{
    return (isDefined(field.child_model));
}
//..............................................................................

//..............................................................................
function fieldIsArray(field)
{
    return (field.isArray);
}
//..............................................................................

//..............................................................................
function fieldIsSimple(field)
{
    var result =
        (
            (isDefined(field.primitive_type)) ||
            (isDefined(field.unit_type     )) ||
            (isDefined(field.picklist_type )) ||
            (isDefined(field.relationship  ))
        );
    return result;
}
//..............................................................................

//..............................................................................
function getFieldDescription(field)
{
    var s = '';

    s += 'field_id:'    + field.id;
    s += ' field_type:' + getFieldType(field);

         if (fieldIsPrimitiveType (field)) s += ' primitive_type:' + field.primitive_type;
    else if (fieldIsUnitType      (field)) s += ' unit_type:'      + field.unit_type;
    else if (fieldIsPicklist      (field)) s += ' picklist:'       + field.picklist_type;
    else if (fieldIsRelationship  (field)) s += ' data_model:'     + field.relationship;
    else if (fieldIsRelatedList   (field)) s += ' related_list:'   + field.related_list;
    else if (fieldIsChildModel    (field)) s += ' child_model:'    + field.child_model;

    if (fieldIsArray(field)) s += ' array:true';

    return s;
}
//..............................................................................

//..............................................................................
function getFieldType(field)
{
    var result;

         if (fieldIsPrimitiveType(field)) result = 'primitive';
    else if (fieldIsUnitType     (field)) result = 'unit';
    else if (fieldIsPicklist     (field)) result = 'picklist';
    else if (fieldIsRelationship (field)) result = 'relationship';
    else if (fieldIsRelatedList  (field)) result = 'related_list';
    else if (fieldIsChildModel   (field)) result = 'child_model';

    return result;

}
//..............................................................................

//..............................................................................
function makeFieldIdFromPath(fieldPath)
{
    return fieldPath.replace(/\./g, '_');
}
//..............................................................................

//..............................................................................
function getFieldDefinitions(dataModelId, attachSystemFields, attachExtraFields)
{
    var metadataProvider = cxq.metadataCache || cxq.cloud;
    var fieldDefinitions = metadataProvider.getDataModel(dataModelId).properties;
    if (!isDefined(attachSystemFields)) attachSystemFields = false;
    if (!isDefined(attachExtraFields )) attachExtraFields  = false;

    if (attachSystemFields)
        processList(cxq.systemFields, function (item) { fieldDefinitions.push(item); });
  //if (attachExtraFields)
  //    processList(cxq.extraFields, function (item) { fieldDefinitions.push(item); });

    return fieldDefinitions;
}
//..............................................................................
function recordAutoComplete(record, dataModelId)
{
    //..........................................................................
    // There are a few rules applicable to the process of completing a record:
    // a) For non-empty fields
    //    1) If a field is modeled as child_model, recursively process the
    //       nesting record instance to the child_model;
    //    2) If a field is not modeled as a child_model, then ignore it.
    // b) For empty fields
    //    1) If a field is not a child_model, set the default value if defined to it;
    //    2) If a field is modeled as a child_model, add the structure of the
    //       child_model and process it with default values defined in its data model;
    //    3) If a field is modeled as an array of child_models, set an empty
    //       array to it;
    //    4) If a field is modeled as an array of relationships, set an empty
    //       array to it.
    //..........................................................................
    function processField(fieldDefinition)
    {
        var id           = fieldDefinition.id;
        var nodeValue    = record[id];
        var isMultiple   = fieldDefinition.isArray;
        var child_model  = fieldDefinition.child_model;
        var relationship = fieldDefinition.relationship;
        var defaultValue = fieldDefinition.default;

        if (isDefined(nodeValue))
        {
            if (isDefined(child_model) && isString(child_model))
                record[id] = recordAutoComplete(nodeValue, child_model);
        }
        else
        {
            if (isDefined(child_model))
            {
                record[id] = isMultiple ?
                     [] :
                     recordAutoComplete({}, child_model);
            }
            else
            if (isDefined(relationship))
            {
                if (isMultiple) record[id] = [];
            }
            else
            if (isDefined(defaultValue))
            {
                record[id] = defaultValue;
            }
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    var fieldDefinitions = getFieldDefinitions(dataModelId);
    processList(fieldDefinitions, processField);
    return record;
}
//..............................................................................

//..............................................................................
function validateDataField(value, fieldDef)
{
    function validatePrimitiveValue()
    {
        var validator =
            cxq.validators[primitiveType] ||
            cxq.util.createPrimitiveTypeValidator(cxq.primitiveTypes[primitiveType]);

        var result = validator(value);
        if (!result.valid)
            return result;
    }
    //..........................................................................
    function validateUnitValue()
    {
        var primitiveType = unitType.primitive_type;
        if (!cxq.validators[primitiveType])
             cxq.util.createPrimitiveTypeValidator(cxq.primitiveTypes[primitiveType]);

        var validator =
            cxq.validators[unitType] ||
            cxq.util.createUnitTypeValidator(cxq.unitTypes[unitType]);

        var result = validator(value);
        if (!result.valid)
            return result;
    }
    ////////////////////////////////////////////////////////////////////////////
    var primitiveType = fieldDef.primitive_type;
    var unitType      = fieldDef.unit_type;

         if (primitiveType) return validatePrimitiveValue();
    else if (unitType     ) return validateUnitValue     ();
}
//..............................................................................

//..............................................................................
function validateRecord(record, tableController, options, callback)
{
    function callback_ValidateIdt(failure)
    {
        if (failure)
            callback(failure);
        else
            validateFields(record);
    }
    //..........................................................................
    function callback_ValidateFields(failure, success)
    {
        if (failure)
            callback(failure);
        else
            callback(null, success.value);

        //console.log(JSON.stringify(failure, null, 2));
    }
    //..........................................................................
    function validateIdt()
    {
        if ('_idt' in record)
            cxq.validators.record_idt.call(options, record.id || record.id, record._idt, callback_ValidateIdt);
        else
            validateFields(record);
    }
    //..........................................................................
    function addCache()
    {
        recordValidatorCache = makeBasicCache({lifetime:oneSecond*180});
    }
    //..........................................................................
    function getOrCreateValidator(cacheKey, dataModel, isDefault)
    {
        if (!recordValidatorCache)
            addCache();

        log.info('getOrCreateValidator:',cacheKey,dataModel);
        var entry = recordValidatorCache.getItem(cacheKey);
        if (isDefined(entry)) return entry;

        var options = {};
        if (isDefault) options.setDefault = true;

        entry = cxq.util.createRecordValidator(dataModel, options);
        recordValidatorCache.addItem(cacheKey, entry);
        return entry;
    }
    //..........................................................................
    function validateFields(record)
    {
        var dataModel;
        var dataModelId;
        var validator;

        if (isDefined(record._idt))
        {
            // validate record against the data-model of its schema
            if (isString(record._idt))
            {
                dataModelId = record._idt;
                validator   = getOrCreateValidator(dataModelId, dataModelId, true);
            }
            else
            if (isObject(record._idt))
            {
                dataModel = record._idt;
                try
                {
                    var hashCode = meshHashHex(JSON.stringify(dataModel));
                    validator = getOrCreateValidator(hashCode, dataModel, false);
                }
                catch (e)
                {
                    callback('invalid _idt field: ' + e);
                }
            }
        }
        else
        {
            if (record._partial)
            {
                // Record fragment validation within which the fields can be one of the
                // sub records of the original enclosing record.
                // So data-model information is computed based on the first/any field key
                // in that the string before the first dot notation is adopted.

                dataModelId = Object.keys(record)[0].split('.')[0]; // fields coming in format like dataModel.field
                validator   = getOrCreateValidator(dataModelId, dataModelId, false);
            }
            else // full record with static data model
            {
                dataModelId = tableController.table.data_model;
                validator   = getOrCreateValidator(dataModelId, dataModelId, true);
            }
        }

        validator.call(options, record, callback_ValidateFields);
    }
    ////////////////////////////////////////////////////////////////////////////
    if (!isObject(record))
    {
        callback('input was not a record');
    }
    else
    if (record._validate === false) // should replace it with a negative flag like ignore_validation
    {
        callback_ValidateFields(null, { value: record });
    }
    else
    if (record._partial)
    {
        // The schema field needs to be checked for consistency between two
        // versions of a record only when an update is in action.
        validateIdt();
    }
    else
    {
        // Validation of a full record is validation of all of its fields.
        validateFields(record);
    }
}
//..............................................................................

addProperties(util,
{
    fieldIsPrimitiveType,
    fieldIsUnitType,
    fieldIsPicklist,
    fieldIsRelationship,
    fieldIsRelatedList,
    fieldIsChildModel,
    fieldIsArray,
    fieldIsSimple,
    getFieldDescription,
    getFieldType,
    makeFieldIdFromPath
});

//..............................................................................
// TODO NM: These are not currently used so hide from the system
//..............................................................................
/*
utils.recordAutoComplete                 = recordAutoComplete                  ;
utils.validateDataField                  = validateDataField                   ;
utils.validateRecord                     = validateRecord                      ;
*/
//..............................................................................
