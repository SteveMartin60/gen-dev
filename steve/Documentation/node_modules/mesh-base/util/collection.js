const deepDiff       = require('deep-diff').diff;
const cloner         = require('clone');
const naturalCompare = require('./natural-compare');

//..............................................................................
const {async, util, _} = cxq;
//..............................................................................

//..............................................................................
const
{
    addProperties,
    makeDate,
    isObject,
    isArray,
    isDefined,
    isPlainObject,
    isFunction,
    isString
} = util;
//..............................................................................

//..............................................................................
const slice         = [].slice;
const filterList    = _.filter;
const processList   = _.each;
//..............................................................................

//..............................................................................
function processFunctionList(fnList)
{
    processList(fnList, function(fn)
    {
        fn();
    });
}
//..............................................................................

//..............................................................................
function processFunctionListParallel(fnList, callback)
{
    if (isObject(fnList))
        fnList = objectToArray(fnList);

    async.parallel(fnList, callback);
}
//..............................................................................

//..............................................................................
function processFunctionListSerial(fnList, callback)
{
    if (isObject(fnList))
        fnList = objectToArray(fnList);

    async.series(fnList, callback);
}
//..............................................................................

//..............................................................................
function processFunctionListWaterfall(fnList, callback)
{
    if (isObject(fnList))
        fnList = objectToArray(fnList);

    async.waterfall(fnList, callback);
}
//..............................................................................

//..............................................................................
function processListParallel(list, fn, callback)
{
    if (!list)
    {
        if (callback) callback(null);
    }
    else
    {
        if (isObject(list))
            list = objectToArray(list);

        async.map(list, fn, callback);
    }
}
//..............................................................................

//..............................................................................
function processListLimit(list, limit, fn, callback)
{
    if (!list)
    {
        if (callback) callback(null);
    }
    else
    {
        if (isObject(list))
            list = objectToArray(list);

        async.mapLimit(list, limit, fn, callback);
    }
}
//..............................................................................

//..............................................................................
function processListSerial(list, fn, callback)
{
    if (!list)
        return callback(null);

    if (isObject(list))
        list = objectToArray(list);

    async.mapSeries(list, fn, callback);
}
//..............................................................................

//..............................................................................
function propertyCount(p)
{
    var result = 0;
    processList(p, function(prop){result++});
    return result;
}
//..............................................................................

//..............................................................................
// Allows a structured key to be used to reference a property in a
// hierarchical record. For example a key "monitor.celsius" on an object like
// {monitor:{celsius:27}} will return the value of monitor.celsius (27)
//..............................................................................
function getPropertyFromStructuredKey(propertyPath, object)
{
    //console.log('getPropertyFromStructuredKey:',propertyPath, object);
    var propertyNames;
    if (isArray(propertyPath))
        propertyNames = propertyPath;
    else
        propertyNames = propertyPath.split('.');

    var propertyDepth = propertyNames.length;
    var i;
    var property = object;
    var indent = '  ';

    for ( i = 0; i < propertyDepth; i++ )
    {
        indent = indent + '  ';
        if (property)
        {
            property = property[propertyNames[i]];
            //console.log(indent,i,'part:' + propertyNames[i],'=>',property);
        }
    }

    return property;
}
//..............................................................................

//..............................................................................
function setPropertyFromStructuredKey(propertyPath, data, object)
{
    var propertyNames;
    if (isArray(propertyPath))
        propertyNames = propertyPath;
    else
        propertyNames = propertyPath.split('.');

    var propertyDepth = propertyNames.length;
    if (!isDefined(object)) object = {};

  //console.log('setPropertyFromStructuredKey:',propertyPath, object, propertyNames, propertyDepth);

    if (propertyDepth == 0)
        return null;

    if (propertyDepth == 1)
    {
        object[propertyPath] = data;
        return object;
    }

    var property    = object;
    var deepestName = propertyNames[propertyDepth-1];
    var indent = '  ';

    for (var i = 0; i < propertyDepth-1; i++)
    {
        indent = indent + '  ';
        var nextPropertyName = propertyNames[i];
        var nextProperty     = property[nextPropertyName];
        if (!nextProperty)
        {
            nextProperty = {};
            property[nextPropertyName] = nextProperty;
        }
        property = nextProperty;
    }

    if (property)
    {
        if (isDefined(data))
            property[deepestName] = data;
        else
            delete property[deepestName];
        return object;
    }

    return null;
}
//..............................................................................

//..............................................................................
function test_setPropertyFromStructuredKey()
{
    var testObject = setPropertyFromStructuredKey('a.b.c.d', 'TestData1');
    testObject = setPropertyFromStructuredKey('a.b.cx.dx.e', 'TestData2', testObject);
    console.log('Test_setPropertyFromStructuredKey:',testObject);
}
//test_setPropertyFromStructuredKey();
//..............................................................................

//..............................................................................
function findInList(object, predicate/* or keyValuePairs */, context)
{
    function findInArray(array)
    {
        var found = null;
        //......................................................................
        function iterator(elem, index, list)
        {
            if (predicate.call(context || null, elem, index, list))
            {
                found = elem;
                return true;
            }
            return false;
        }
        ////////////////////////////////////////////////////////////////////////
        array.some(iterator);
        return found;
    }
    //..........................................................................
    function findInObject(object, predicate, context)
    {
        var found;
        context = context || null;

        if (typeof predicate !== 'function')
        {
            var keyValuePairs = predicate;
            return _.findWhere(object, keyValuePairs);
        }
        else
        {
            if (predicate.call(context, object))
            {
                return object;
            }

            for (var key in object)
            {
                if (object.hasOwnProperty(key))
                {
                    if (predicate.call(context, object[key]))
                    {
                        found = object[key];
                        return found;
                    }
                    else
                    {
                        if ( isPlainObject(object[key]) && Object.keys(object[key]).length )
                        {
                            found = findInObject(object[key], predicate, context);
                            if (found) return found;
                        }
                    }
                }
            }
            return found;
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    if (isArray(object))
    {
        return findInArray(object);
    }
    else
    if (isObject(object))
    {
        return findInObject(object, predicate, context);
    }
}
//..............................................................................

//..............................................................................
function removeArrayElements(array, predicate, context)
{
    if (!isArray(array) || !array.length || !isFunction(predicate)) return array;

    for (var i = 0; i < array.length; i++)
    {
        if (predicate.call(context || null, array[i]))
        {
            array.splice(i, 1);
            break;
        }
    }
    return array;
}
//..............................................................................

//..............................................................................
// Merges the source objects into the destination object.
// If override is enabled, values of fields in the destination
// object will be overridden. By default override is true.
//..............................................................................
function mergeObjectDeep(override, destination/*, obj1, obj2, ... , objN*/)
{
    var sourceObjects;
    var i;
    var currentKey;
    var currentObject;
    var targetObject;

    if (typeof override !== 'boolean')
    {
        targetObject = override;
        sourceObjects = slice.call(arguments).slice(1);
        override      = true;
    }
    else
    {
        targetObject  = destination;
        sourceObjects = slice.call(arguments).slice(2);
    }

    for (i = 0; i < sourceObjects.length; i++)
    {
        for (currentKey in sourceObjects[i])
        {
            if (sourceObjects[i].hasOwnProperty(currentKey))
            {
                currentObject = sourceObjects[i][currentKey];
                if (targetObject.hasOwnProperty(currentKey) && isDefined(targetObject[currentKey]))
                {
                    if (isPlainObject(currentObject))
                    {
                        mergeObjectDeep(override, targetObject[currentKey], currentObject);
                    }
                    else
                    if (override && targetObject[currentKey] !== currentObject)
                    {
                        targetObject[currentKey] = currentObject;
                    }
                }
                else
                {
                    targetObject[currentKey] = currentObject;
                }
            }
        }
    }
    return targetObject;
}
//..............................................................................

//..............................................................................
// Properties of object will be named from the key field in the array objects
//..............................................................................
function arrayToObject(arr, key)
{
    var result = {};
    processList(arr, function(item)
    {
        result[item[key]] = item;
    });
    return result;
}
//..............................................................................

//..............................................................................
function objectToArray(p)
{
    return _.toArray(p);
}
//..............................................................................

//..............................................................................
function compareObjects(o1,o2)
{
    return deepDiff(o1,o2);
}
//..............................................................................

//..............................................................................
function map(list, iterator)
{
    return _.map(list, iterator);
}
//..............................................................................

//..............................................................................
function contains(list, value, startIndex)
{
    return _.contains(list, value, startIndex);
}
//..............................................................................

//..............................................................................
// http://underscorejs.org/#sortBy
// sortKey can be a property of the object in the array or a function that
// returns the actual sort key.
//..............................................................................
function sortArray(unsortedArray, sortKey)
{
    return _.sortBy(unsortedArray, sortKey);
}
//..............................................................................

//..............................................................................
function forceToArray(item)
{
    if (!isDefined(item))
        return[];
    else
    if (!isArray(item))
        return [item];
    else
        return item;
}
//..............................................................................

//..............................................................................
function deepCloneAsString(p)
{
    var pIsObject = isObject(p);
    var pIsArray  = isArray (p);

    if (pIsObject || pIsArray)
    {
        try
        {
            return JSON.parse(JSON.stringify(p));
        }
        catch(e)
        {
            console.error('deepCloneAsString:parseError', p,e.stack);

                 if (pIsObject) return {};
            else if (pIsArray ) return [];
            else               return null;
        }
    }
    else
    {
        return p;
    }
}
//..............................................................................

//..............................................................................
function deepClone(p)
{
    var pIsObject = isObject(p);
    var pIsArray  = isArray (p);

    if (pIsObject || pIsArray)
    {
        try
        {
            return cloner(p);
        }
        catch(e)
        {
            console.error('deepClone:parseError', p,e.stack);

                 if (pIsObject) return {};
            else if (pIsArray ) return [];
            else               return null;
        }
    }
    else
    {
        return p;
    }
}
//..............................................................................

//..............................................................................
function deepObjectCompare(p1,p2)
{
    return _.isEqual(p1,p2);
}
//..............................................................................

//..............................................................................
// find all the properties that meet the requirement by the given test function
//..............................................................................

//..............................................................................
function findProperties(obj, test)
{
    var found = []; // stores matched property references as an array
    //..........................................................................
    function processNode(node)
    {
        if (test(node))
            found.push(node);
    }
    //..........................................................................
    function walk(node, visitor)
    {
        visitor(node);
        if (isPlainObject(node) && Object.keys(node).length > 0)
        {
            for ( var key in node ) walk(node[key], visitor);
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    walk(obj, processNode);
    return found;
}
//..............................................................................

//..............................................................................
function mergeArray(override/* array1, array2, ... , arrayN */)
{
    var arrays = [].slice.call(arguments).slice(1);
    override   = override || false;
    //..........................................................................
    function reducer(prev, current)
    {
        function mergeElements(elem, index)
        {
            if (isDefined(current[index]))
            {
                if (override && current[index] !== elem)
                    current[index] = elem;
            }
            else
            {
                current[index] = elem;
            }
        }
        prev.forEach(mergeElements);
        return current;
    }
    ////////////////////////////////////////////////////////////////////////////
    return arrays.reduceRight(reducer);
}
//..............................................................................

//..............................................................................
function flattenObject(object, target, prefix)
{
    var cFlattenArrays = false;
    prefix = prefix || '';
    //..........................................................................
    function processItem(result, value, key)
    {
        if ((!cFlattenArrays) && isArray(value))
        {
            var ar = [];
            result[prefix + key] = ar;
            for (var i=0; i<value.length;i++)
            {
                var newElement = {};
                ar.push(newElement);
                flattenObject(value[i], newElement);
            }
        }
        else
        if (isObject(value))
        {
            flattenObject(value, result, prefix + key + '.');
        }
        else
        {
            result[prefix + key] = value;
        }
        return result;
    }
    ////////////////////////////////////////////////////////////////////////////
    return _.reduce(object, processItem, target || {});
}
//..............................................................................
function unFlattenObject(object)
{
    function processItem(result, value, keys)
    {
        var current    = result;
        var partitions = keys.split('.');
        var limit      = partitions.length - 1;
        //......................................................................
        function processPartition(key, index)
        {
            var item;// (index == limit ? value : (current[key] || {}));
            if (index == limit)
            {
                if (isArray(value))
                {
                    item = [];
                    //console.log('foundArray:',key,'=',value);
                    for (var i=0; i<value.length;i++)
                    {
                        var newElement = unFlattenObject(value[i]);
                        item.push(newElement);
                    }
                }
                else
                {
                    item = value;
                }
            }
            else
            {
                item = (current[key] || {});
            }

            //console.log('processPartition:',key,index);
            current = current[key] = item; //(index == limit ? value : (current[key] || {}));
        }
        ////////////////////////////////////////////////////////////////////////
        processList(partitions, processPartition);
        return result;
    }
    ////////////////////////////////////////////////////////////////////////////
    return _(object).reduce(processItem,{});
}
//..............................................................................

//..............................................................................
function flattenObjectsInArray(a)
{
    processList(a, function (item, index)
    {
        a[index] = flattenObject(a[index])
    });
}
//..............................................................................

//..............................................................................
function randomArrayElement(array)
{
    var r = Math.floor(Math.random() * array.length);
    return array[r];
}
//..............................................................................

//..............................................................................
// Elements of the array must be objects
// Will add an _age property to the array elements.
//..............................................................................
function sortArrayByDateProperty(list, propertyId)
{
    function addAge(e)
    {
        e.millisecondAge = 0;
        if (isString(e[propertyId]))
        {
            var d = makeDate(e[propertyId]);
            if (d)
                e.millisecondAge = d.getTime();
        }
    }
    //..........................................................................
    function removeAge(e)
    {
        delete e.millisecondAge;
    }
    //..........................................................................
    function compareEntities(e1,e2)
    {
        try
        {
                 if (e1.millisecondAge > e2.millisecondAge) return -1;
            else if (e1.millisecondAge < e2.millisecondAge) return +1;
            else                                            return  0;
        }
        catch (e)
        {
          log.error('ERROR: sortEntities:', e1,e2);
          return 0;
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    processList(list,addAge);
    var result = list.sort(compareEntities);
    processList(list,removeAge);
    return result;
}
//..............................................................................

//..............................................................................
function propertiesAsSortedArray(obj, key='id')
{
    function compare(e1,e2)
    {
        try
        {
                 if (e1[key] > e2[key]) return +1;
            else if (e1[key] < e2[key]) return -1;
            else                      return  0;
        }
        catch (e)
        {
          log.error('ERROR: propertiesAsSortedArray.compare:', e1,e2);
          return 0;
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    if (key=='id')
    {
        return Object.keys(obj).sort(compare).map(function(key){return obj[key];});
    }
    else
    {
        var arr = objectToArray(obj);
        return arr.sort(compare);
    }
}
//..............................................................................

//..............................................................................
function sortedKeysAsString(obj)
{
    return Object.keys(obj).sort().join(' ');
}
//..............................................................................


addProperties(util,
{
    slice,
    processList,
    filterList,
    processFunctionList,
    processFunctionListParallel,
    processFunctionListSerial,
    processFunctionListWaterfall,
    processListParallel,
    processListSerial,
    processListLimit,
    propertyCount,
    getPropertyFromStructuredKey,
    setPropertyFromStructuredKey,
    findInList,
    removeArrayElements,
    mergeObjectDeep,
    arrayToObject,
    objectToArray,
    compareObjects,
    map,
    contains,
    sortArray,
    forceToArray,
    deepClone,
    deepCloneAsString,
    deepObjectCompare,
    findProperties,
    mergeArray,
    flattenObject,
    unFlattenObject,
    flattenObjectsInArray,
    randomArrayElement,
    sortArrayByDateProperty,
    propertiesAsSortedArray,
    sortedKeysAsString,
    naturalCompare
});
