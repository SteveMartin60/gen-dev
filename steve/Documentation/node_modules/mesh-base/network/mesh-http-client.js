//..............................................................................
const
{
    logger,
    makeEventEmitter,
    meshSessionTokenIdentifier,
    util
} = cxq;
//..............................................................................

//..............................................................................
const
{
    addToNameSpace,
    isDefined,
    isArray,
    mergeObjectDeep,
    isString,
    getObjectFromString,
    meshNowMs,
    msAsId,
    randomBase32,
    functionAsProperty_ReadOnly
} = util;
//..............................................................................

//..............................................................................
const log = logger('http-client');
log.setLevel('info');
//..............................................................................

//..............................................................................
const method  = {get:'get', post:'post', delete:'delete', put:'put'};
//..............................................................................

//..............................................................................
const emitter = makeEventEmitter();
const timeoutId = 524;
//..............................................................................

//..............................................................................
function showRequest(url)
{
    var ignore = false;

    if (url.indexOf('https://localhost:3049/v0/actions'          ) >= 0) ignore = true;
    if (url.indexOf('https://localhost:3004/v0/machine/processes') >= 0) ignore = true;
    if (url.indexOf('https://localhost:3004/v0/machine/id'       ) >= 0) ignore = true;
    if (url.indexOf('https://localhost:3039/v0/resources'        ) >= 0) ignore = true;
    if (url.indexOf('https://localhost:3039/v0/services'         ) >= 0) ignore = true;

    return false;
    //return !ignore;
}
//..............................................................................

//..............................................................................
function getBaseHttpOptions(url, p)
{
    var options =
    {
        url     : url,
        headers : {}
    };

    if (p)
    {
        if (p.headers) options.headers = p.headers;
        if (p.timeout) options.timeout = p.timeout;
    }

    if (cxq.credentials && cxq.credentials.certs && cxq.credentials.certs.machine)
    {
     // if (showRequest(url)) console.log('addingCertificateToRequest:',url);
     // console.log('default:',cxq.credentials.certs.machine);
     // console.log('key:'    ,cxq.credentials.key          );
     // console.log('ca:'     ,cxq.credentials.ca           );

        options.cert               = cxq.credentials.certs.machine;
        options.key                = cxq.credentials.key;
        options.ca                 = cxq.credentials.ca;
        options.agent              = false;
        options.requestCert        = true;
        options.rejectUnauthorized = false;
    }

    var sessionToken, sessionDomain;

    if (p && p.sessionToken)
    {
        log.debug('Request using session token in settings', p.sessionToken);
        sessionToken = p.sessionToken;
    }
    else
    if (cxq.cloud.sessionToken)
    {
        //log.info('Request using session token in cloud.sessionToken', cxq.cloud.sessionToken);
        sessionToken = cxq.cloud.sessionToken;

        if (cxq.cloud.sessionType === 'person')
            sessionToken += '|' + cxq.cloud.sessionDomain;
    }
  //else
  //if (cxq.machine && cxq.machine.sessionToken)
  //{
  //    log.info('Request using machine.sessionToken', cxq.machine.sessionToken);
  //    sessionToken = cxq.machine.sessionToken;
  //}

    if (sessionToken)
    {
        //if (showRequest(url)) log.info('addingSessionToRequest:',sessionToken, url);
        options.headers[meshSessionTokenIdentifier] = sessionToken;
        //log.info('AddingSession:',sessionToken, options.headers[meshSessionTokenIdentifier]);
    }
    else
    {
        if (showRequest(url))
            log.debug('makingUnAuthenticatedRequest:',url);
    }

    return options;
}
//..............................................................................

//..............................................................................
function buildUrl(urlStructure)
{
    if (isArray(urlStructure))
        return urlStructure.join('/');
    else
        return urlStructure;
}
//..............................................................................

//..............................................................................
function getDataFromBody(body)
{
    var data;
    if (isString(body))
        data = getObjectFromString(body);
    else
        data = body;
    return data;
}
//..............................................................................

//..............................................................................
function makeRequest(url, options, callback)
{
    return cxq.request(url, options, function(err, response, body)
    {
        if (err)
        {
         // log.error('makeRequest:',url, err.error);
            if (err.error && err.error.code === 'api_validation_error')
            {
                log.error('makeRequest:',url, err.error);
                emitter.emit('error',err.error);
            }
        }
        else
        {
            //log.info('makeRequest:',url, response);
        }

        callback(err, response, body);
    });
}
//..............................................................................

//..............................................................................
function baseHttpGet(url, p, callback)
{
    var options = getBaseHttpOptions(url, p);
    options.method  = 'GET';
    makeRequest(url, options, callback);
}
//..............................................................................

//..............................................................................
function baseHttpPost(url, data, p, callback)
{
    var options = getBaseHttpOptions(url, p);
    options.method  = 'POST';
    options.json    = data;
    //console.log('####################### baseHttpPost:',url,options,data);
    makeRequest(url, options, callback);
}
//..............................................................................

//..............................................................................
function baseHttpPut(url, data, p, callback)
{
    var options = getBaseHttpOptions(url, p);
    options.method  = 'PUT';
    options.json    = data;
    makeRequest(url, options, callback);
}
//..............................................................................

//..............................................................................
function baseHttpDelete(url, data, p, callback)
{
    var options = getBaseHttpOptions(url, p);
    options.method = 'DELETE';
    if (data) options.json = data;
    makeRequest(url, options, callback);
}
//..............................................................................

//..............................................................................
const tracker =
{
    pending       : {},
    finished      : {},
    errors        : [],
    pendingCount  : 0,
    finishedCount : 0
};
//..............................................................................

//..............................................................................
function addPending(requestInfo)
{
    requestInfo.state = 'pending';
    requestInfo.id    = msAsId(requestInfo.start) + '-' + randomBase32(4);
  //log.info('addPending:', requestInfo.id, requestInfo.url, requestInfo);

    tracker.pending[requestInfo.id] = requestInfo;
    tracker.pendingCount++;
    emitter.emit('begin' , requestInfo, tracker);
    emitter.emit('change', requestInfo, tracker);
}
//..............................................................................

//..............................................................................
function addFinished(requestInfo)
{
    requestInfo.state = 'finished';
  //log.info('addFinished:', requestInfo.id, requestInfo.url, 'Time:', requestInfo.elapsed, requestInfo);

    if (tracker.pending[requestInfo.id])
    {
        delete tracker.pending[requestInfo.id];
    }
    else
    {
        console.error('ERROR:Missing Pending Request:',requestInfo);
        tracker.errors.push(requestInfo);
    }

    tracker.finished[requestInfo.id] = requestInfo;

    tracker.pendingCount--;
    tracker.finishedCount++;

    emitter.emit('end'   , requestInfo, tracker);
    emitter.emit('change', requestInfo, tracker);
}
//..............................................................................

//..............................................................................
function httpGet(p, urlStructure, callback)
{
    // p can be a single record id or an array of record ids
    var recordData = null;
    var requestInfo =
    {
        start  : meshNowMs(),
        url    : buildUrl(urlStructure),
        data   : p,
        method : 'get'
    };
    addPending(requestInfo);

    //..........................................................................
    function callback_Local(err, response, body)
    {
        requestInfo.end     = meshNowMs();
        requestInfo.elapsed = requestInfo.end - requestInfo.start;
        addFinished(requestInfo);

        var status = null;
        if (response) status = response.statusCode;
      //console.log('HttpGet_callback:', p, status, err, body);
        if (err)
        {
            //console.log('HttpGet.callback_Local Error:', err);
            if (callback) callback(err)
        }
        else
        if (response.statusCode == 200)
        {
            if (callback)
            {
                if (p && p.raw)
                    callback(null, body);
                else
                    callback(null, getDataFromBody(body));
            }
        }
        else
        {
            if (!body) body = {};

            body.statusCode = response.statusCode;
            body.msg        = 'Failed to GET ' + recordData;
            if (callback) callback(body)
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    var url = requestInfo.url;
    if (isDefined(p) && isDefined(p.query))
        url = url +'?' + p.query;

    //console.log('client.get:', url, p);
    baseHttpGet(url, p, callback_Local);
}
//..............................................................................

//..............................................................................
function httpPostPut(httpMethod, p, urlStructure, callback)
{
    var recordData = null;
    var requestInfo =
    {
        start  : meshNowMs(),
        url    : buildUrl(urlStructure),
        data   : p,
        method : httpMethod
    };
    addPending(requestInfo);
    //..........................................................................
    function callback_Local(err, response, body)
    {
        requestInfo.end     = meshNowMs();
        requestInfo.elapsed = requestInfo.end - requestInfo.start;
        addFinished(requestInfo);

        if (err)
        {
            //console.log('WebWrapper.httpPostPut.callback_Local Error:', err);

            if (callback) callback(err)
        }
        else
        if ((response.statusCode == 200) || (response.statusCode == 201)) //201 means a new record was added
        {
            if (callback)
                callback(null, getDataFromBody(body));
        }
        else
        {
            if (!body) body = {};

            body.statusCode = response.statusCode;
            body.msg        = 'Failed to ' + httpMethod + ' ' + recordData;
            if (callback) callback(body)
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    var url = buildUrl(urlStructure);
    //console.log('http.' + httpMethod, p.data, url);

    if (httpMethod == method.put)
        baseHttpPut (url, p.data, p, callback_Local);
    else
        baseHttpPost(url, p.data, p, callback_Local);
}
//..............................................................................

//..............................................................................
function httpPost(p, urlStructure, callback)
{
    httpPostPut(method.post, p, urlStructure, callback);
}
//..............................................................................

//..............................................................................
function httpPut(p, urlStructure, callback)
{
    httpPostPut(method.put, p, urlStructure, callback);
}
//..............................................................................

//..............................................................................
function httpDelete(p, urlStructure, callback)
{
    // p can be a single record id or an array of record ids
    var recordData = null;
    //..........................................................................
    var callback_Local = function(err, response, body)
    {
        var msg = 'Failed to DELETE ' + recordData;
        if (err)
        {
            msg = msg + ' ' + err;
            console.log('   deleteRecords Error:', err);
            if (callback) callback(msg)
        }
        else
        if (response.statusCode == 200)
        {
            if (callback)
                callback(null, getDataFromBody(body));
        }
        else
        {
            if (!body) body = {};

            body.statusCode = response.statusCode;
            body.msg = msg;
            if (callback) callback(body)
        }
    };
    ////////////////////////////////////////////////////////////////////////////
    if (isArray(p))
        recordData = {records:p};
    else
    if (isString(p))
        urlStructure.push(p);

    var url = buildUrl(urlStructure);
    baseHttpDelete(url, recordData, p, callback_Local);
}
//..............................................................................

//..............................................................................
function httpStreamedUpload(url, options, callback)
{
    function extractPathFromUrl(url)
    {
        var splitedUrl = url.split('/');
        var extracted = {};
        for (var index = 0; index < splitedUrl.length; index++)
        {
            var pathItem = splitedUrl[index];
            if (pathItem == "files" && index + 1 < splitedUrl.length)
            {
                extracted.requestUrl     = splitedUrl.slice(0, index + 2).join('/');
                extracted.uploadFullPath = splitedUrl.slice(index + 2).join('/');
                break;
            }
        }
        if (extracted.uploadFullPath)
        {
            return extracted;
        }
        else
        {
            return null;
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    log.debug('httpStreamedUpload:',url,options);
    var extracted = extractPathFromUrl(url);
    if (extracted)
    {
        url = extracted.requestUrl;
        var httpOptions = getBaseHttpOptions(options.url, options);
        httpOptions.method = 'POST';
        httpOptions.url    = url;
        mergeObjectDeep(true, httpOptions, options);

        httpOptions.headers['upload-fullpath'] = extracted.uploadFullPath;
        log.debug('baseStreamedUpload_Option:',url,httpOptions);
        return makeRequest(url, httpOptions, callback);
    }
    else
    {
        callback('Fail to parse URL');
    }
}
//..............................................................................

//..............................................................................
function httpStreamedDownload(url, writeStream, callback)
{
    var options    = getBaseHttpOptions(url);
    options.method = 'GET';
    options.stream = writeStream;
    makeRequest(url, options, callback);
}
//..............................................................................

//..............................................................................
const httpClient =
{
    get              : httpGet              ,
    post             : httpPost             ,
    put              : httpPut              ,
    delete           : httpDelete           ,
    streamedUpload   : httpStreamedUpload   ,
    streamedDownload : httpStreamedDownload ,
    tracker,
    on               : emitter.on
};
functionAsProperty_ReadOnly(httpClient, function(){return timeoutId}, 'timeoutId');
//..............................................................................



addToNameSpace(httpClient, 'httpClient');

//..............................................................................
// Example tracking of requests
// ----------------------------
//cxq.httpClient.on('change', function(action, tracker)
//{
//    log.info('handleHttpAction pending:',tracker.pendingCount, 'finished:',tracker.finishedCount, action);
//});
//..............................................................................