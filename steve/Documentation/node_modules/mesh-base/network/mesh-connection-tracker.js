//..............................................................................
const {util} = cxq;
//..............................................................................

//..............................................................................
const
{
    meshNowMs,
    functionAsProperty_ReadOnly
} = util;
//..............................................................................

var eventTypes =
{
    statusChange    : {id:'statusChange'    ,description_en : 'Connection status has changed'    },
    stillConnected  : {id:'stillConnected'  ,description_en : 'Still connected to server'        },
    connectionLost  : {id:'connectionLost'  ,description_en : 'Existing connection has been lost'},
    connectFailure  : {id:'connectFailure'  ,description_en : 'Attempt to connect failed'        },
    reconnectFailure: {id:'reconnectFailure',description_en : 'Attempt to reconnect failed'      },
    connected       : {id:'connected'       ,description_en : 'Successfully connected'           },
    reconnected     : {id:'reconnected'     ,description_en : 'Successfully reconnected'         }
};
cxq.connectionEvents = eventTypes;

//..............................................................................
// Tracks an abstract connection.
// Create the object and then call the updateStatus function whenever its
// connected or disconnected.
// Emits events on the supplied owner's emitter, based on the current and past
// state of the connection.
//..............................................................................
function makeConnectionTracker(connectionId, owner)
{
    //console.log('trackerInit:',connectionId,owner);
    var hasBeenConnected      = false;
    var wasConnectedLastCheck = false;

    //..........................................................................
    function updateStatus(connected, ping)
    {
        var idString = 'connectionTracker[' + owner.id +']:';
        //......................................................................
        function emitEvent(event, secondary)
        {
            var e =
            {
                id                    : event.id,
                description_en        : event.description_en,
                wasConnectedLastCheck : wasConnectedLastCheck,
                hasBeenConnected      : hasBeenConnected
            };
            if (secondary) e.secondary = secondary;
            if (ping     ) e.ping      = ping;


          //console.log('TrackerEmitEvent:',event,e,owner);
            owner.emit(event.id, e, owner);
        }
        ////////////////////////////////////////////////////////////////////////
        if (connected)
        {
            if (!hasBeenConnected)
            {
                hasBeenConnected      = true;
                wasConnectedLastCheck = true;
                //Never connected Before - so this is first successful connection
                console.log(idString + 'Successfully established connection');
                emitEvent(eventTypes.connected);
                emitEvent(eventTypes.statusChange, eventTypes.connected);
            }
            else
            if (wasConnectedLastCheck)
            {
                //Still connected
                //console.log(idString + 'Connection is still active');
                emitEvent(eventTypes.stillConnected);
                emitEvent(eventTypes.statusChange, eventTypes.stillConnected);
            }
            else
            {
                wasConnectedLastCheck = true;
                //Successful reconnection after losing connection
                console.log(idString + 'Successfully reconnected');
                emitEvent(eventTypes.reconnected);
                emitEvent(eventTypes.statusChange, eventTypes.reconnected);
            }
        }
        else //Not connected now
        {
            if (wasConnectedLastCheck)
            {
                wasConnectedLastCheck = false;
                //Previously connected - have now lost the connection
                console.log(idString + 'Lost Connection to Server');
                emitEvent(eventTypes.connectionLost);
                emitEvent(eventTypes.statusChange, eventTypes.connectionLost);
            }
            else
            if (!hasBeenConnected)
            {
                //Never previously connected - still cannot connect
                //console.log(idString+ 'Failed to Establish Connection');
                emitEvent(eventTypes.connectFailure);
                emitEvent(eventTypes.statusChange, eventTypes.connectFailure);
            }
            else
            {
                //has been connected in the past but still failing to reconnect
                //console.log(idString + 'Failed to Reconnect');
                emitEvent(eventTypes.reconnectFailure);
                emitEvent(eventTypes.statusChange, eventTypes.reconnectFailure);
            }
        }
    }
    ////////////////////////////////////////////////////////////////////////////
    var publicScope =
    {
        updateStatus
    };
    functionAsProperty_ReadOnly(publicScope, function(){return connectionId         ;}, 'id'                   );
    functionAsProperty_ReadOnly(publicScope, function(){return hasBeenConnected     ;}, 'hasBeenConnected'     );
    functionAsProperty_ReadOnly(publicScope, function(){return wasConnectedLastCheck;}, 'wasConnectedLastCheck');

    return publicScope;
}
//..............................................................................

module.exports = makeConnectionTracker;
cxq.makeConnectionTracker = makeConnectionTracker;

//..............................................................................
// This simple latency test runs multiple connections in parallel and gets
// the average response time. If the client machine is starved for resources
// (shortage of sockets, event-loop-lag etc) then will give misleading results.
//..............................................................................
var getConnectionLatency = function(connection, pingAction, callback)
{
    //..........................................................................
    var maxTestCount = 10;
    var responseCount= 0;
    var errorCount   = 0;
    var latencyCount = 0;
    var latencySum   = 0;
    var overallStart = meshNowMs();
    //..........................................................................
    var initiateSingleTest = function()
    {
        var start = meshNowMs();
        //......................................................................
        var callback_PingAction = function(error, response, body)
        {
            responseCount++;

            if (error)
            {
                errorCount ++;
                console.log('getConnectionLatency error:',error);
            }
            else
            if (!response || !body)
            {
                errorCount ++;
                console.log('getConnectionLatency error:','bad response from server');
            }
            else //Good response
            {
                var now = meshNowMs();
                var latency = now - start;
                //console.log('latencyCount:'+latencyCount, 'latencyResponse:',latency, 'now:'+now, 'start:'+start);
                latencyCount++;
                latencySum += latency;
            }

            if (responseCount == maxTestCount)
            {
                var overallFinish = meshNowMs();

                var averageLatency = latencySum / latencyCount;
                var overallTime    = overallFinish-overallStart;
                console.log('averageLatency:'+averageLatency,'ms', 'OverallTime:'+ overallTime,'ms');
                if (callback)
                {
                    if (errorCount)
                    {
                        callback('getConnectionLatency errors:',errorCount);
                    }
                    else
                    {
                        callback(null, averageLatency);
                    }
                }
            }
        };
        ////////////////////////////////////////////////////////////////////////
        pingAction(connection,callback_PingAction);
    };
    ////////////////////////////////////////////////////////////////////////////
    for (var i=0; i < maxTestCount; i++)
        initiateSingleTest();
};
//..............................................................................
