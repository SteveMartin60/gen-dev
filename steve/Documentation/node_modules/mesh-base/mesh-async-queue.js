//..............................................................................
const {async, makeEventEmitter, util} = cxq;
//..............................................................................

//..............................................................................
const
{
    padNumber,
    addToNameSpace,
    functionAsProperty_ReadOnly,
    meshNowMs
} = util;
//..............................................................................

//..............................................................................
var queueCount = 0;
//..............................................................................

//..............................................................................
function makeAsyncQueue(processFn, options={})
{
    queueCount++;
    var queue;
    var id          = options.id || padNumber(queueCount, 5);
    var queueMap    = {};
    var emitter     = makeEventEmitter();
    var latency     = 0;
    var activeCount = 0;
    //..........................................................................
    function getEntry(itemKey)
    {
        return queueMap[itemKey] || null;
    }
    //..........................................................................
    function queueItemUpdate(data, itemKey)
    {
     // console.log('queueItemUpdate:',data,itemKey);
        if (itemKey && queueMap[itemKey]) //Already in queue, so just update
        {
         // console.log('queueItemUpdate:updating:',data,itemKey);
            var queueEntry = queueMap[itemKey];
            queueEntry.data = data;
            queueEntry.time = meshNowMs();
            return true;
        }
        else
        {
         // console.log('queueItemUpdate:notFound:',data,itemKey);
            return false;
        }
    }
    //..........................................................................
    function queueItemAdd(data, itemKey)
    {
     // console.log('queueItemAdd:',data,itemKey);
        var time       = meshNowMs();
        var queueEntry = {data, time};
        //......................................................................
        function postProcess(err)
        {
            activeCount--;
            delete queueMap[itemKey];
            latency = meshNowMs() - queueEntry.time;
            if (err)
                emitter.emit('error'    , queueEntry.itemKey, queueEntry.data);
            else
                emitter.emit('processed', queueEntry.itemKey, queueEntry.data);
        }
        ////////////////////////////////////////////////////////////////////////
        if (itemKey)
        {
            queueEntry.itemKey = itemKey;
            queueMap[itemKey] = queueEntry;
        }
        activeCount++;
        queue.push(queueEntry, postProcess);
    }
    //..........................................................................
    function push(itemKey, data)
    {
        if (!data) return;

        if (!queueItemUpdate(data, itemKey))
             queueItemAdd   (data, itemKey);
    }
    //..........................................................................
    function handledQueueDrained()
    {
     // console.log('All items have been processed');
        emitter.emit('drained', id);
    }
    ////////////////////////////////////////////////////////////////////////////
    queue = async.queue(processFn, options.concurrency || 1);
    queue.drain = handledQueueDrained;

    var publicScope =
    {
        push,
        getEntry,
        on : emitter.on
    };

    functionAsProperty_ReadOnly(publicScope, function(){return activeCount;}, 'length' );
    functionAsProperty_ReadOnly(publicScope, function(){return latency;    }, 'latency');
    functionAsProperty_ReadOnly(publicScope, function(){return id;         }, 'id'     );
    return publicScope;
}
//..............................................................................

addToNameSpace(makeAsyncQueue, 'makeAsyncQueue');

