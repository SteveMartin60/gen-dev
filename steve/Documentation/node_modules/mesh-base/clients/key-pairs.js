const crypto  = require('crypto');

//..............................................................................
const {cloud, fs, logger, path, pathCredentials, util} = cxq;
//..............................................................................

//..............................................................................
const
{
    abort,
    addProperties,
    stringToSha256MultiHash,
    processFunctionListSerial,
    doCallback,
    isFunction,
    isBuffer,
} = util;
//..............................................................................

//..............................................................................
const log = logger('key-pairs');
log.setLevel('info');
//..............................................................................

//..............................................................................
function generateKeyPairRSA(callback)
{
    function dump({id, publicKey, privateKey})
    {
        log.debug('---------------------------------------------------------');
        log.debug('Generated publicKey:', id);
        log.debug('---------------------------------------------------------');
        log.debug( publicKey );
        log.debug();
        log.debug('---------------------------------------------------------');
        log.debug('privateKey');
        log.debug('---------------------------------------------------------');
        log.debug( privateKey);
        log.debug();
        log.debug('---------------------------------------------------------');
    }
    /////////////////////////////////////////////////////////////////////////////
    const props =
    {
        modulusLength     : 2048,
        publicKeyEncoding : {type: 'spki' , format: 'pem'},
        privateKeyEncoding: {type: 'pkcs8', format: 'pem'}
    };

    if (callback)
    {
        let result = null;
        crypto.generateKeyPair('rsa',props, function(err, publicKey, privateKey)
        {
            if (publicKey && privateKey)
            {
                const id = stringToSha256MultiHash(publicKey);
                result = {id, publicKey, privateKey};
                dump(result);
            }
            callback(err, result);
        });
    }
    else
    {
        const {publicKey, privateKey} = crypto.generateKeyPairSync('rsa', props);
        const id = stringToSha256MultiHash(publicKey);
        const result = {id, publicKey, privateKey};
        dump(result);
        return result;
    }
}
//..............................................................................

//..............................................................................
function getExistingKeyPair(id, options, mainCallback)
{
    if (isFunction(options))
    {
        mainCallback = options;
        options = {};
    }

    const publicKeyPath  = path.join(pathCredentials, 'key-pairs', id + '-public.key');
    const privateKeyPath = path.join(pathCredentials, 'key-pairs', id + '-private.key');
    let   publicKey  = null;
    let   privateKey = null;
    let   hashCheck  = false;
    //..........................................................................
    function loadPublicKey(callback)
    {
        fs.readFile(publicKeyPath, 'utf8', function(err, data)
        {
            if (data)
                publicKey = data;

            log.debug('Existing Public Key:', id, '\n', publicKey);
            callback(null);
        });
    }
    //..........................................................................
    function loadPrivateKey(callback)
    {
        fs.readFile(privateKeyPath, 'utf8', function(err, data)
        {
            if (data)
                privateKey = data;

            log.debug('Existing Private Key:', id, '\n', privateKey);
            callback(null);
        });
    }
    //..........................................................................
    function getFromCloud(callback)
    {
        if (publicKey)
            return doCallback(callback);

        cloud.getOnePubkeyOpen(id, function(err, data)
        {
            if (data)
            {
                log.debug('GotKey:',err, data);
                if (isBuffer(data))
                    data = data.toString();
                const key = data;
                log.debug('getFromCloud:done:',{id, key});
                publicKey = key;
                fs.writeFile(publicKeyPath , key , 'utf8', function(err)
                {
                    callback(null);
                });
            }
            else
            {
                console.warn('Missing Cloud Key:',err);
                callback(null);
            }
        });
    }
    //..........................................................................
    function validatePublicKey(callback)
    {
        if (!publicKey)
             return doCallback(callback);

        const expectedId = stringToSha256MultiHash(publicKey);
        hashCheck = (id === expectedId);
        if (!hashCheck)
        {
            log.warn('PublicKey Failed Hash Check:',{id, expectedId});
        }
        doCallback(callback);
    }
    ////////////////////////////////////////////////////////////////////////////
    const execution = [loadPublicKey, loadPrivateKey, getFromCloud, validatePublicKey];

    processFunctionListSerial(execution, function(err)
    {
        log.debug('getExistingKeyPair:done:',err);
        if (err)
            mainCallback(err , {});
        else
            mainCallback(null, {publicKey, privateKey, hashCheck});
    });
}
//..............................................................................

//..............................................................................
function saveKeyFilesLocally(keyInfo, mainCallback)
{
    const newPrivateKeyPath = path.join(pathCredentials, 'key-pairs', keyInfo.id + '-private.key');
    const newPublicKeyPath  = path.join(pathCredentials, 'key-pairs', keyInfo.id + '-public.key' );
    //..........................................................................
    function savePublic(callback)
    {
        fs.writeFile(newPublicKeyPath, keyInfo.publicKey, 'utf8', callback);
    }
    //..........................................................................
    function savePrivate(callback)
    {
        fs.writeFile(newPrivateKeyPath, keyInfo.privateKey, 'utf8', callback);
    }
    ////////////////////////////////////////////////////////////////////////////
    log.debug('Saving:', {newPrivateKeyPath,newPublicKeyPath, keyInfo});
    processFunctionListParallel([savePublic, savePrivate], mainCallback);
}
//..............................................................................

//..............................................................................
function addNewKeyPair(mainCallback)
{
    let keyInfo   = null;
    //..........................................................................
    function makePair(callback)
    {
        generateKeyPairRSA(function(err,data)
        {
            keyInfo = data || null;
            callback(err);
        });
    }
    //..........................................................................
    function addToCloud(callback)
    {
        cloud.addPubkey({id:keyInfo.id, key:keyInfo.publicKey}, function(err, data)
        {
            keyInfo.record = data || null;
            callback(err);
        });
    }
    //..........................................................................
    function saveLocally(callback)
    {
        saveKeyFilesLocally(keyInfo, callback);
    }
    ////////////////////////////////////////////////////////////////////////////
    processFunctionListSerial([makePair, addToCloud, saveLocally], function(err)
    {
        mainCallback(err, keyInfo);
    });
}
//..............................................................................

addProperties(util,
{
    getExistingKeyPair,
    addNewKeyPair,
});
