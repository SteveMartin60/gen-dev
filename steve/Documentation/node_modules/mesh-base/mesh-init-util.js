//..............................................................................
const {_} = cxq;
//..............................................................................

//..............................................................................
// Only add functions to cxq.util here if they are needed in mesh-init
//..............................................................................

//..............................................................................
function isDefined(x)
{
    return (typeof x != 'undefined' && x != null);
}
//..............................................................................

//..............................................................................
function isString(x)
{
    return _.isString(x);
}
//..............................................................................

//..............................................................................
function isFunction(x)
{
    return x && typeof x === 'function' && Object.prototype.toString.call(x) === '[object Function]';
}
//..............................................................................

//..............................................................................
function isArray(x)
{
    return Array.isArray(x);
}
//..............................................................................

//..............................................................................
function isArrayWithElements(x)
{
    return (isArray(x) && x.length > 0);
}
//..............................................................................

//..............................................................................
function isObject(x)
{
    return _.isObject(x);
}
//..............................................................................

//..............................................................................
function isPlainObject(x)
{
    if ( typeof x !== 'object' ) return false;

    try
    {
        if ( x.constructor &&
            !x.hasOwnProperty('constructor') && !x.constructor.prototype.isPrototypeOf(Object))
        {
            return false;
        }
    }
    catch (e)
    {
        return false;
    }

    return true;
}
//..............................................................................

//..............................................................................
function isNumeric(n)
{
    var result = false;
    if (isObject(n))
        return result;
    
    try
    {
        result = !isNaN(parseFloat(n)) && isFinite(n);
    }
    catch(e)
    {
        console.error('ERROR:isNumeric:',e, '\nValue:',n);
    }

    return result;
}
//..............................................................................

//..............................................................................
function isDate(n)
{
    return _.isDate(n);
}
//..............................................................................

//..............................................................................
function isInteger(x)
{
    return Number.isInteger(x);
}
//..............................................................................

//..............................................................................
function isBoolean(x)
{
    return typeof x == 'boolean';
}
//..............................................................................

//..............................................................................
function isBuffer(n)
{
    return (n instanceof Buffer);
}
//..............................................................................

//..............................................................................
function promoteScope_ReadOnly(targetScope, sourceScope, propertyId)
{
    //targetScope .__defineGetter__(propertyId, function() {return sourceScope[propertyId];});\
    var options =
    {
        configurable : false,
        enumerable   : true,
        get          : function(){return sourceScope[propertyId]}
    };

    Object.defineProperty(targetScope, propertyId, options);
}
//..............................................................................

//..............................................................................
function promoteScope_ReadWrite(targetScope, sourceScope, propertyId)
{
    //targetScope .__defineGetter__(propertyId, function(   ) {return sourceScope[propertyId];});
    //targetScope .__defineSetter__(propertyId, function(val) {       sourceScope[propertyId] = val;});
    var options =
    {
        configurable : false,
        enumerable   : true,
        get          : function(   ){return sourceScope[propertyId]      },
        set          : function(val){       sourceScope[propertyId] = val}
    };

    Object.defineProperty(targetScope, propertyId, options);
}
//..............................................................................

//..............................................................................
function functionAsProperty_ReadOnly(targetScope, fn, propertyId)
{
    var options =
    {
        configurable : false,
        enumerable   : true,
        get          : function(){return fn();}
    };

    Object.defineProperty(targetScope, propertyId, options);
}
//..............................................................................

//..............................................................................
function functionAsProperty_ReadWrite(targetScope, getFn, setFn, propertyId)
{
    var options =
    {
        configurable : false,
        enumerable   : true,
        get          : function(        ){return getFn() ;},
        set          : function(newValue){setFn(newValue);}
    };

    Object.defineProperty(targetScope, propertyId, options);
}
//..............................................................................

//..............................................................................
function addProperties(destination, source)
{
    return _.extend(destination, source);
}
//..............................................................................

// Can add
// Object  : Create a read-only property getter on cxq that returns the object
// function : just add the function to cxq. line makeEventEmitter
// string   : assume this is a constant so make a function that returns the value
//..............................................................................
function addToNameSpace(objectOrFunction, key)
{
    if (isString(objectOrFunction))
    {
     // console.log('addToNameSpace:string   as:', key);//, 'content:',objectOrFunction);
        functionAsProperty_ReadOnly(cxq, function(){return objectOrFunction}, key);
    }
    else
    if (isFunction(objectOrFunction))
    {
     // console.log('addToNameSpace:function as:', key);//, 'content:',objectOrFunction);
        functionAsProperty_ReadOnly(cxq, function(){return objectOrFunction}, key);
    }
    else
    if (isObject(objectOrFunction))
    {
     // console.log('addToNameSpace:object   as:', key);//, 'content:',objectOrFunction);
        functionAsProperty_ReadOnly(cxq, function(){return objectOrFunction}, key);
    }
    else
    {
        console.error('addToNameSpace:',key, 'content:',objectOrFunction);
    }
}
//..............................................................................

//..............................................................................
const util =
{
    isDefined,
    isString,
    isFunction,
    isArray,
    isArrayWithElements,
    isObject,
    isPlainObject,
    isInteger,
    isNumeric,
    isDate,
    isBoolean,
    isBuffer,
    promoteScope_ReadOnly,
    promoteScope_ReadWrite,
    functionAsProperty_ReadOnly,
    functionAsProperty_ReadWrite,
    addProperties,
    addToNameSpace
};
//..............................................................................

addToNameSpace(util, 'util');
